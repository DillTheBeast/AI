
import customtkinter as ctk
from tkinter import filedialog, messagebox
import open3d as o3d
import numpy as np
import os
import subprocess

class ImageTo3DApp(ctk.CTk):
    def __init__(self):
        super().__init__()

        self.title("Image to 3D Model Converter")
        self.geometry("400x300")

        self.upload_button = ctk.CTkButton(self, text="Upload Images", command=self.upload_images)
        self.upload_button.pack(pady=20)

        self.convert_button = ctk.CTkButton(self, text="Convert to 3D Model", command=self.convert_to_3d)
        self.convert_button.pack(pady=20)

        self.image_paths = []
        self.output_dir = "colmap_output"

        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)

    def upload_images(self):
        file_types = [("Image files", "*.jpg *.jpeg *.png")]
        self.image_paths = filedialog.askopenfilenames(title="Select Images", filetypes=file_types)
        if self.image_paths:
            messagebox.showinfo("Info", f"{len(self.image_paths)} images selected.")

    def convert_to_3d(self):
        if not self.image_paths:
            messagebox.showerror("Error", "No images uploaded.")
            return

        self.run_colmap()
        output_ply = self.generate_point_cloud()
        if output_ply:
            output_stl = self.convert_ply_to_stl(output_ply)
            if output_stl:
                messagebox.showinfo("Success", f"3D model saved as {output_stl}")

    def run_colmap(self):
        # Create necessary directories for COLMAP
        os.makedirs(os.path.join(self.output_dir, "sparse"), exist_ok=True)
        os.makedirs(os.path.join(self.output_dir, "dense"), exist_ok=True)

        # Feature extraction
        subprocess.run([
            "colmap", "feature_extractor",
            "--database_path", os.path.join(self.output_dir, "database.db"),
            "--image_path", os.path.join(self.output_dir, "images"),
            "--ImageReader.single_camera", "1"
        ])

        # Feature matching
        subprocess.run([
            "colmap", "exhaustive_matcher",
            "--database_path", os.path.join(self.output_dir, "database.db")
        ])

        # Structure from motion
        subprocess.run([
            "colmap", "mapper",
            "--database_path", os.path.join(self.output_dir, "database.db"),
            "--image_path", os.path.join(self.output_dir, "images"),
            "--output_path", os.path.join(self.output_dir, "sparse")
        ])

        # Image undistortion
        subprocess.run([
            "colmap", "image_undistorter",
            "--image_path", os.path.join(self.output_dir, "images"),
            "--input_path", os.path.join(self.output_dir, "sparse", "0"),
            "--output_path", os.path.join(self.output_dir, "dense"),
            "--output_type", "COLMAP"
        ])

        # Dense reconstruction
        subprocess.run([
            "colmap", "patch_match_stereo",
            "--workspace_path", os.path.join(self.output_dir, "dense"),
            "--workspace_format", "COLMAP",
            "--PatchMatchStereo.geom_consistency", "true"
        ])

        # Stereo fusion
        subprocess.run([
            "colmap", "stereo_fusion",
            "--workspace_path", os.path.join(self.output_dir, "dense"),
            "--workspace_format", "COLMAP",
            "--input_type", "geometric",
            "--output_path", os.path.join(self.output_dir, "dense", "fused.ply")
        ])

    def generate_point_cloud(self):
        # Path to the fused point cloud generated by COLMAP
        fused_ply = os.path.join(self.output_dir, "dense", "fused.ply")
        if os.path.exists(fused_ply):
            return fused_ply
        else:
            messagebox.showerror("Error", "Failed to generate point cloud.")
            return None

    def convert_ply_to_stl(self, ply_file):
        # Read the PLY file
        pcd = o3d.io.read_point_cloud(ply_file)

        # Compute normals
        pcd.estimate_normals()

        # Perform Poisson surface reconstruction
        mesh, densities = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(pcd, depth=9)
        
        # Remove low-density vertices
        vertices_to_remove = densities < np.quantile(densities, 0.01)
        mesh.remove_vertices_by_mask(vertices_to_remove)

        # Save the mesh to an STL file
        output_stl = "output.stl"
        o3d.io.write_triangle_mesh(output_stl, mesh)
        return output_stl

if __name__ == "__main__":
    app = ImageTo3DApp()
    app.mainloop()
